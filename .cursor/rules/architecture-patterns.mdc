# Architecture Patterns for NumSwift

## Multi-Target Architecture

### Target Separation
- **NumSwift**: High-level Swift APIs, operator overloads, protocol extensions
- **NumSwiftC**: Low-level C implementations for performance-critical operations
- **NumSwiftMetal**: GPU-accelerated operations using Metal framework (embedded within NumSwift)

### Target Dependencies
- NumSwift depends on NumSwiftC for CPU operations
- NumSwiftMetal is embedded within NumSwift target for seamless integration
- Metal backend provides automatic fallback to CPU when GPU is unavailable
- Avoid circular dependencies between targets

### Metal Backend Architecture
The Metal implementation follows a three-layer architecture:
1. **Metal Shaders** (`NumSwiftMetal.metal`): GPU compute kernels for all operations
2. **Swift Wrapper** (`NumSwiftMetal.swift`): Automatic backend selection and Metal resource management
3. **Unified API**: Same interface for CPU and GPU operations with transparent switching

## Swift/C/Metal Integration

### C Function Wrapper Pattern
```swift
// Swift wrapper in NumSwiftC/NumSwiftC.swift
public func convolution2D<T: Numeric>(_ input: [T], ...) -> [T] {
    // Parameter validation
    // Call C function
    // Handle result
}
```

### Metal Backend Integration Pattern
```swift
// Metal backend wrapper in NumSwiftMetal.swift
public func convolution2D(_ input: [[Float16]], _ filter: [[Float16]]) -> [[Float16]] {
    if shouldUseMetal(for: input.count * input[0].count) {
        return metalConv2D(input, filter)
    } else {
        return cpuConv2D(input, filter) // Falls back to C implementation
    }
}
```

### Backend Selection Architecture
The Metal backend uses intelligent switching:
- **Problem Size Analysis**: Evaluates array size to determine optimal backend
- **Hardware Detection**: Considers GPU capabilities and availability
- **Automatic Fallback**: Seamlessly falls back to CPU if Metal fails
- **Performance Monitoring**: Can adapt thresholds based on runtime performance

### C Implementation Guidelines
- All C functions use `numswiftc_` prefix
- Header declarations in `include/numswiftc.h` must match implementations
- Use consistent parameter ordering: input, dimensions, output
- Return error codes for validation failures

## Header/Implementation Synchronization

### Critical Requirements
- Function signatures in header files MUST match implementations exactly
- Parameter names should be consistent between header and implementation
- All public C functions must be declared in headers
- Use proper C calling conventions

### Example Pattern
```c
// In numswiftc.h
int numswiftc_convolution2d(const float* input, int input_height, int input_width, 
                           const float* kernel, int kernel_height, int kernel_width,
                           float* output, int stride_h, int stride_w);

// In numswiftc.c - signature must match exactly
int numswiftc_convolution2d(const float* input, int input_height, int input_width, 
                           const float* kernel, int kernel_height, int kernel_width,
                           float* output, int stride_h, int stride_w) {
    // Implementation
}
```

## Platform-Specific Code

### Preprocessor Conditions
- Use `#if arch(arm64)` for ARM64-specific optimizations
- Use `#if os(iOS)` for iOS-specific functionality
- Always provide fallback implementations

### Float16 Architecture Handling
```swift
#if arch(arm64)
// Float16 implementation
extension Float16: BaseNumeric {
    // ARM64-specific Float16 code
}
#endif
```

## Module Organization

### File Structure Patterns
- Group related functionality in dedicated files
- Keep protocol extensions separate from concrete implementations
- Organize C code by functionality (convolution, matrix ops, etc.)

### Public API Design
- Expose only necessary types and functions as public
- Keep implementation details internal
- Use consistent naming across all targets

## Error Handling Architecture

### C Layer Error Handling
- C functions return integer error codes
- 0 = success, negative values = specific errors
- Swift layer translates error codes to Swift errors

### Swift Layer Error Handling
```swift
public enum NumSwiftError: Error {
    case dimensionMismatch
    case invalidParameter
    case allocationFailure
}
```

## Memory Management

### Cross-Language Memory Handling
- Swift manages high-level object lifecycle
- C functions work with raw pointers
- No memory allocation in C layer - Swift provides buffers
- Use `withUnsafeBufferPointer` for safe C interop

### Metal Memory Management
- Use `storageModeShared` for CPU-GPU data sharing
- Implement buffer pooling for frequent operations
- Manage Metal resource lifecycle properly
- Handle GPU memory pressure with automatic fallback

### Buffer Management Pattern
```swift
// Efficient Metal buffer creation and reuse
private func createBuffer<T>(from data: [T], type: T.Type) -> MTLBuffer? {
    let size = data.count * MemoryLayout<T>.stride
    
    // Try to reuse buffer from pool
    if let buffer = getBufferFromPool(size: size) {
        copyDataToBuffer(data, buffer)
        return buffer
    }
    
    // Create new buffer with shared storage
    return device.makeBuffer(bytes: data, length: size, options: .storageModeShared)
}
```